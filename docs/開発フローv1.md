#📅 Cryptomeria 統合開発ロードマップ (TDD & Hono BFF)

##🛠️ 開発プロセス（全フェーズ共通）各機能の実装は以下のサイクルで行います。

1. **Design**: 型定義（DTO / Schema）とAPIインターフェースの決定
2. **Test (Red)**: 期待する挙動（「APIが200を返す」「DBにレコードが作成される」等）をテストコードで記述
3. **Develop**: Honoサーバーへの機能実装
4. **Connect**: フロントエンド（WebUI）のMockServiceWorkerをオフにし、実APIへ接続
5. **Test (Green)**: 結合テストのパス確認

---

##Phase 1: コア実験ループの確立 (Experiment & Library)**目的**: WebUIからシナリオを受け取り、BFFが実際にCoreへ負荷をかけ、その結果を永続化・表示できるようにする。

###📋 実装機能・API仕様| 機能 | メソッド | エンドポイント | 通信 | 概要 |
| --- | --- | --- | --- | --- |
| **実験実行** | `POST` | `/api/experiment/run` | HTTP | WebUIからシナリオJSONを受け取り、バックグラウンドで負荷試験ジョブを開始する。<br>

<br>レスポンスで `jobId` を即時返却。 |
| **進捗監視** | `WS` | `/ws/experiment/:jobId` | WS | 実行中のジョブの進捗（アップロード済みMB、ログ）をリアルタイム配信。 |
| **結果取得** | `GET` | `/api/library/results` | HTTP | SQLiteに保存された実験結果一覧を返す。 |
| **結果詳細** | `GET` | `/api/library/results/:id` | HTTP | 特定の実験の詳細データを返す。 |

###🏗️ バックエンド設計 (BFF)* **Load Generator Engine (Core Logic)**:
* シナリオJSON（データサイズ、送信戦略）を解析。
* 指定サイズ分のランダムデータをメモリ上またはストリームで生成。
* GWCの `http_handler` に対して `multipart/form-data` でデータをPOSTするクライアント機能。
* まずは「シングルアップロード（戦略なし）」のみ実装。


* **Persistence Layer**:
* `SQLite` + `Drizzle ORM` (または Prisma) を使用。
* テーブル: `ExperimentResults`, `ExperimentLogs`



###✅ 完了条件 (Definition of Done)1. **[TDD]** `POST /run` に対する単体テストが通り、ジョブがキューイングされること。
2. **[Backend]** BFFからGWCに対して実際にファイルアップロードが成功すること（GWCのログで確認）。
3. **[Frontend]** WebUIの「シナリオ作成」ボタンを押して実験を開始し、終了後に「ライブラリ」画面で結果が表示されること。
4. **[Data]** SQLiteファイルに実験レコードが正しく保存されていること。

---

##Phase 2: システム制御と環境操作 (Deployment & Control)**目的**: 実験条件を変えるために、WebUIからインフラ（ノード数、Relayer）を直接操作できるようにする。

###📋 実装機能・API仕様| 機能 | メソッド | エンドポイント | 通信 | 概要 |
| --- | --- | --- | --- | --- |
| **ノードスケール** | `POST` | `/api/deployment/scale` | HTTP | KubernetesのStatefulSet (FDSC) のレプリカ数を変更する。 |
| **Relayer制御** | `POST` | `/api/deployment/relayer` | HTTP | RelayerのDeploymentを `replicas: 1` (Start) または `0` (Stop) にする。 |
| **環境リセット** | `DELETE` | `/api/deployment/reset` | HTTP | チェーンデータ(PVC)を削除し、Podを再起動する。 |

###🏗️ バックエンド設計 (BFF)* **K8s Client Wrapper**:
* `@kubernetes/client-node` ライブラリを使用。
* In-Cluster Config（Pod内実行時）または Kubeconfig（ローカル開発時）でクラスタ認証。
* `apps/v1` APIを用いて `scale` メソッドを実行するサービスクラスを実装。



###✅ 完了条件 (Definition of Done)1. **[TDD]** Kubernetes APIのモックを用いたテストで、指定したレプリカ数の更新リクエストが正しく発行されること。
2. **[Backend]** BFFのAPIを叩くと、実際のKubernetesクラスタ上で `fdsc-1`, `fdsc-2` などのPodが起動/終了すること。
3. **[Frontend]** WebUIのデプロイ画面でスライダーを操作して「適用」を押すと、実際のインフラ構成が変化すること。

---

##Phase 3: モニタリングとユーザー管理 (Monitoring & Users)**目的**: 実験中のブロック生成状況を可視化し、システムの状態を正しく把握できるようにする。

###📋 実装機能・API仕様| 機能 | メソッド | エンドポイント | 通信 | 概要 |
| --- | --- | --- | --- | --- |
| **ブロック監視** | `WS` | `/ws/monitoring/blocks` | WS | Tendermint RPCのイベントを購読し、WebUI向けフォーマットに変換して配信。 |
| **ユーザー一覧** | `GET` | `/api/economy/users` | HTTP | GWCコンテナ内の `gwc keys list` コマンド実行結果、またはKeyringファイルをパースして返す。 |

###🏗️ バックエンド設計 (BFF)* **WebSocket Proxy**:
* HonoのWebSocketサポートを利用。
* バックエンドで Core (Tendermint) の `/websocket` に接続 (`subscribe "tm.event='NewBlock'"` )。
* 受信したイベントを `BlockEvent` 型（WebUI定義）に変換し、接続中のフロントエンドクライアントへブロードキャストする。


* **User Service**:
* `kubectl exec` 相当の機能、またはGWCが提供するAPIを用いてアカウント一覧を取得。
* 「役割」フィールドは削除または固定値（default）としてマッピング。



###✅ 完了条件 (Definition of Done)1. **[TDD]** ダミーのTendermintイベントを入力させ、期待通りのJSONフォーマットでWebSocketメッセージが送出されること。
2. **[Backend]** 実際のチェーン稼働中に、BFF経由でブロック生成イベントが流れ続けること。
3. **[Frontend]** WebUIの「モニタリング」画面で、ブロックがリアルタイムに右から左へ流れるアニメーションが動作すること。
4. **[Frontend]** 「経済」画面で、GWCに登録されている実アカウントのアドレスが表示されること。

---

##📈 TDD開発フローの具体例###Phase 1: 実験実行 (Experiment Run)1. **定義 (Type Definition)**
* WebUI側と型を合わせるため、`ScaleRequestSchema` (zod) 等を参照し、BFF側で `RunExperimentRequest` 型を定義。


2. **テスト作成 (Test First)**
* `tests/experiment.test.ts` を作成。
* **Case**: `POST /api/experiment/run` に `{ virtualConfig: { sizeMB: 100 } }` を送信。
* **Expect**: ステータス `202 Accepted`、およびレスポンスボディに `{ jobId: "..." }` が含まれることを検証するテストを書く（Fail確認）。


3. **BFF実装 (Implementation)**
* Honoのハンドラを実装。まずは `return c.json({ jobId: "test-id" }, 202)` だけでテストをパスさせる。
* 次に内部ロジック（`ExperimentRunner` クラス等）を実装し、GWCへのモックリクエストが飛ぶことを確認するテストを追加・実装する。


4. **接続 (Integration)**
* WebUIの `api.experiment.run` メソッド内の `fetch` URLをBFFに向ける。



###Phase 2: デプロイメント操作 (Scale FDSC)1. **定義 (Type Definition)**
* リクエストボディ型定義: `type ScaleRequest = { replicaCount: number; }`


2. **テスト作成 (Test First)**
* `tests/deployment.test.ts` を作成。
* Kubernetesクライアント (`@kubernetes/client-node`) を `vitest` でモック化する。
* **Case**: `POST /api/deployment/scale` に `{ replicaCount: 5 }` を送信。
* **Expect**: モックされたK8sクライアントの `patchNamespacedStatefulSetScale` メソッドが、引数 `5` で1回呼び出されることを検証するテストを書く。


3. **BFF実装 (Implementation)**
* 実際にK8sクライアントをインスタンス化し、APIリクエストの値を使ってスケールさせるロジックを実装する。


4. **接続 (Integration)**
* WebUIのデプロイ画面のスライダー操作と連携確認。



###Phase 3: リアルタイム監視 (Monitoring Proxy)1. **定義 (Type Definition)**
* `TendermintBlockEvent` (入力: Coreからの生データ) と `WebUIBlockEvent` (出力: WebUI用) の型を定義。


2. **テスト作成 (Test First)**
* `tests/monitoring.test.ts` を作成。
* **Case**: 監視ロジッククラスに `TendermintBlockEvent` のダミーJSONを入力する。
* **Expect**: 変換ロジックを経て、HonoのWebSocketクライアントモックに対して、正しい形式の `WebUIBlockEvent` JSONが `send` されることを検証する。


3. **BFF実装 (Implementation)**
* TendermintへのWebSocket接続を行い、受信データを変換して `ws.send()` するパイプラインを実装する。


4. **接続 (Integration)**
* WebUIの `BlockFeed` コンポーネントがBFFのWebSocketに接続し、グラフが描画されることを確認。